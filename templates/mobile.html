<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>VoxGraph - Mobile Input</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; height: 100vh; margin: 0; }
        #controls { padding: 15px; border-bottom: 1px solid #ccc; background-color: #f8f8f8; text-align: center; }
        #controls button { padding: 12px 20px; font-size: 1.1em; cursor: pointer; margin-right: 10px; border-radius: 5px;}
        #status { margin-top: 8px; font-style: italic; min-height: 1.2em; font-size: 0.9em;}
        #query-section { flex-grow: 1; padding: 15px; display: flex; flex-direction: column; overflow-y: hidden; }
        #query-section h2 { margin-top: 0; text-align: center; }
        #queryInput { width: calc(100% - 22px); padding: 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1em;}
        #queryButton { padding: 10px 15px; width: 100%; font-size: 1em; border-radius: 5px; background-color: #4CAF50; color: white; border: none;}
        #queryResultContainer { flex-grow: 1; overflow-y: auto; margin-top: 15px; border: 1px solid #eee; border-radius: 5px;}
        #queryResult { white-space: pre-wrap; background-color: #f9f9f9; padding: 10px; min-height: 50px; }
        .error { color: red; font-weight: bold; }
        /* Style for the generated links */
        #queryResult a { color: navy; text-decoration: underline; }
    </style>
</head>
<body>

    <div id="controls">
        <button id="toggleAudioButton">Start Listening</button>
        <div id="status">Status: Disconnected</div>
    </div>

    <div id="query-section">
        <h2>Query Knowledge Graph</h2>
        <input type="text" id="queryInput" placeholder="Enter your query...">
        <button id="queryButton">Ask</button>
        <div id="queryResultContainer">
             <div id="queryResult">Query results will appear here.</div>
        </div>
    </div>

    <script>
        const toggleAudioButton = document.getElementById('toggleAudioButton');
        const statusDiv = document.getElementById('status');
        const queryInput = document.getElementById('queryInput');
        const queryButton = document.getElementById('queryButton');
        const queryResultDiv = document.getElementById('queryResult');

        // --- Config ---
        const SERVER_URL = `http://${window.location.hostname}:${window.location.port}`;
        const TARGET_SAMPLE_RATE = 16000;
        const WORKLET_PROCESSOR_NAME = 'audio-processor';
        const WORKLET_PATH = '/static/audio-processor.js';
        // Regex for likely CIDv1 (base32 - bafy... or bafk...)
        // Adjust length check {50,} if needed, based on your CIDs
        const CID_REGEX = /baf[ky][a-z2-7]{50,}/gi;
        // Choose your preferred IPFS gateway
        const IPFS_GATEWAY = "https://gateway.lighthouse.storage/ipfs/"; // Or "https://ipfs.io/ipfs/"

        // --- State ---
        let socket = null;
        let audioContext = null;
        let microphoneNode = null;
        let audioWorkletNode = null;
        let isStreaming = false;
        let sourceStream = null;

        // --- Socket.IO Connection ---
        function connectSocket() {
            // ... (keep existing connectSocket logic) ...
            if (socket && socket.connected) return;
            updateStatus("Connecting...");
            socket = io(SERVER_URL);

            socket.on('connect', () => {
                updateStatus("Connected. Ready.");
                toggleAudioButton.disabled = false;
                queryButton.disabled = false;
                queryInput.disabled = false;
            });

            socket.on('disconnect', (reason) => {
                updateStatus(`Disconnected: ${reason}`, true);
                if (isStreaming) {
                    forceStopStreamingCleanup();
                }
                toggleAudioButton.textContent = 'Start Listening';
                toggleAudioButton.disabled = true;
                queryButton.disabled = true;
                queryInput.disabled = true;
            });

            socket.on('connect_error', (err) => {
                updateStatus(`Connection error: ${err.message}`, true);
                toggleAudioButton.disabled = true;
                queryButton.disabled = true;
                queryInput.disabled = true;
            });

            socket.on('error', (data) => {
                updateStatus(`Server error: ${data.message}`, true);
            });

             // Listen for query results
            socket.on('query_result', (data) => {
                console.log("Query result:", data);
                queryButton.disabled = false; // Re-enable button
                queryInput.disabled = false;
                queryResultDiv.classList.remove('error'); // Clear previous errors

                if (data.processing) {
                    queryResultDiv.textContent = data.answer; // Display processing message as text
                 } else if (data.error || !data.answer) {
                    queryResultDiv.textContent = `Error: ${data.answer || 'Empty response from server'}`; // Display errors as text
                    queryResultDiv.classList.add('error');
                } else {
                    // *** NEW LOGIC: Set text, then linkify CIDs ***
                    const rawAnswer = data.answer;
                    // 1. Set the raw text content first (safer)
                    queryResultDiv.textContent = rawAnswer;

                    // 2. Find CIDs in the raw text and replace them in the displayed HTML
                    // We need to use innerHTML for the replacement part
                    let currentHtml = queryResultDiv.innerHTML; // Get HTML representation of the text just set
                    const updatedHtml = currentHtml.replace(CID_REGEX, (cid) => {
                        const linkUrl = `${IPFS_GATEWAY}${cid}`;
                        // Create the link HTML string
                        return `<a href="${linkUrl}" target="_blank" rel="noopener noreferrer">${cid}</a>`;
                    });

                    // 3. Update the div's content with the HTML containing links
                    queryResultDiv.innerHTML = updatedHtml;
                }
            });

            // Listen for server confirmation of start/stop
             socket.on('audio_started', () => {
                if (!isStreaming) { console.log("Ignoring stale audio_started"); return; }
                updateStatus("Streaming audio...");
                toggleAudioButton.textContent = 'Stop Listening';
                toggleAudioButton.disabled = false;
            });

            socket.on('audio_stopped', (data) => {
                const reason = data?.message || "Server initiated stop";
                updateStatus(`Stopped: ${reason}`);
                 if (isStreaming) { forceStopStreamingCleanup(); }
                toggleAudioButton.textContent = 'Start Listening';
                toggleAudioButton.disabled = !(socket && socket.connected);
            });
        }

        // --- Audio Processing ---
        // (Keep startStreaming, stopStreaming, forceStopStreamingCleanup as before)
        async function startStreaming() {
             if (isStreaming || !socket || !socket.connected) return;
             updateStatus("Initializing audio...");
             toggleAudioButton.disabled = true;
             try {
                 if (!audioContext || audioContext.state === 'closed') audioContext = new AudioContext({ sampleRate: TARGET_SAMPLE_RATE });
                 if (audioContext.state === 'suspended') await audioContext.resume();
                 if (!audioContext.audioWorklet) { updateStatus("Error: AudioWorklet unavailable (HTTPS required).", true); toggleAudioButton.disabled = false; return; }
                 try { await audioContext.audioWorklet.addModule(WORKLET_PATH); } catch (e) { updateStatus(`Error: Could not load audio processor. ${e.message}`, true); toggleAudioButton.disabled = false; return; }
                 sourceStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, sampleRate: TARGET_SAMPLE_RATE } });
                 microphoneNode = audioContext.createMediaStreamSource(sourceStream);
                 audioWorkletNode = new AudioWorkletNode(audioContext, WORKLET_PROCESSOR_NAME);
                 audioWorkletNode.port.onmessage = (event) => { if (socket && socket.connected && isStreaming) socket.emit('audio_chunk', event.data); };
                 audioWorkletNode.port.onerror = (event) => { updateStatus(`Audio processing error: ${event.message || 'Unknown'}`, true); stopStreaming(); };
                 microphoneNode.connect(audioWorkletNode);
                 audioWorkletNode.connect(audioContext.destination);
                 socket.emit('start_audio');
                 isStreaming = true;
                 updateStatus("Waiting for server confirmation...");
             } catch (err) { updateStatus(`Error: ${err.message}`, true); forceStopStreamingCleanup(); toggleAudioButton.disabled = !(socket && socket.connected); }
         }
        function stopStreaming() {
             if (!isStreaming) return;
             console.log("User requested stop.");
             isStreaming = false;
             if (socket && socket.connected) socket.emit('stop_audio');
             forceStopStreamingCleanup();
             toggleAudioButton.textContent = 'Start Listening';
             updateStatus("Stopped listening.");
             toggleAudioButton.disabled = !(socket && socket.connected);
         }
        function forceStopStreamingCleanup() {
             console.log("Cleaning up audio resources...");
             isStreaming = false;
             if (audioWorkletNode) { audioWorkletNode.port.onmessage = null; audioWorkletNode.port.onerror = null; try { audioWorkletNode.disconnect(); } catch(e){} audioWorkletNode = null; }
             if (microphoneNode) { try { microphoneNode.disconnect(); } catch(e){} microphoneNode = null; }
             if (sourceStream) { sourceStream.getTracks().forEach(track => track.stop()); sourceStream = null; console.log("Mic stream tracks stopped."); }
             console.log("Audio cleanup finished.");
        }

        // --- Query Handling ---
        // (Keep sendQuery as before)
         function sendQuery() {
             const query = queryInput.value.trim();
             if (!query) { queryResultDiv.textContent = "Please enter a query."; queryResultDiv.classList.add('error'); return; }
             if (!socket || !socket.connected) { queryResultDiv.textContent = "Not connected."; queryResultDiv.classList.add('error'); return; }
             queryResultDiv.textContent = "Sending query..."; queryResultDiv.classList.remove('error');
             queryButton.disabled = true; queryInput.disabled = true;
             socket.emit('query_graph', { query: query });
         }

        // --- Status Update ---
        // (Keep updateStatus as before)
        function updateStatus(message, isError = false) {
            console.log(`Status: ${message}`);
            statusDiv.textContent = `Status: ${message}`;
            statusDiv.className = isError ? 'error' : '';
        }

        // --- Event Listeners ---
        // (Keep event listeners as before)
        toggleAudioButton.addEventListener('click', () => { if (!isStreaming) startStreaming(); else stopStreaming(); });
        queryButton.addEventListener('click', sendQuery);
        queryInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') { event.preventDefault(); sendQuery(); } });
        document.addEventListener('DOMContentLoaded', () => { connectSocket(); toggleAudioButton.disabled = true; queryButton.disabled = true; queryInput.disabled = true; });
        window.addEventListener('beforeunload', () => { if (socket) socket.disconnect(); });

    </script>
</body>
</html>