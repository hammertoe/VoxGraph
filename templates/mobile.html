<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>VoxGraph - Mobile Input</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; height: 100vh; margin: 0; }
        #controls { padding: 15px; border-bottom: 1px solid #ccc; background-color: #f8f8f8; text-align: center; }
        #controls button { padding: 12px 20px; font-size: 1.1em; cursor: pointer; margin-right: 10px; border-radius: 5px;}
        /* Style for the volume meter */
        #volumeMeterContainer {
            height: 20px; /* Height of the meter */
            width: 90%;  /* Width relative to controls */
            max-width: 300px; /* Max width */
            background-color: #e0e0e0;
            border: 1px solid #ccc;
            margin: 10px auto 5px auto; /* Center and space */
            position: relative;
            overflow: hidden;
            border-radius: 3px;
        }
        #volumeLevel {
            background-color: #4CAF50; /* Green bar */
            height: 100%;
            width: 0%; /* Start at 0 */
            position: absolute;
            left: 0;
            top: 0;
            transition: width 0.05s linear; /* Smooth transition */
        }
         /* Hide meter when not streaming */
        #volumeMeterContainer.hidden {
            display: none;
        }
        #status { margin-top: 0px; font-style: italic; min-height: 1.2em; font-size: 0.9em;}
        #query-section { flex-grow: 1; padding: 15px; display: flex; flex-direction: column; overflow-y: hidden; }
        #query-section h2 { margin-top: 0; text-align: center; }
        #queryInput { width: calc(100% - 22px); padding: 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1em;}
        #queryButton { padding: 10px 15px; width: 100%; font-size: 1em; border-radius: 5px; background-color: #4CAF50; color: white; border: none;}
        #queryResultContainer { flex-grow: 1; overflow-y: auto; margin-top: 15px; border: 1px solid #eee; border-radius: 5px;}
        #queryResult { white-space: pre-wrap; background-color: #f9f9f9; padding: 10px; min-height: 50px; }
        .error { color: red; font-weight: bold; }
        #queryResult a { color: navy; text-decoration: underline; }
    </style>
</head>
<body>

    <div id="controls">
        <button id="toggleAudioButton">Start Listening</button>
        <!-- Add the volume meter elements -->
        <div id="volumeMeterContainer" class="hidden">
            <div id="volumeLevel"></div>
        </div>
        <div id="status">Status: Disconnected</div>
    </div>

    <div id="query-section">
        <h2>Query Knowledge Graph</h2>
        <input type="text" id="queryInput" placeholder="Enter your query...">
        <button id="queryButton">Ask</button>
        <div id="queryResultContainer">
             <div id="queryResult">Query results will appear here.</div>
        </div>
    </div>

    <script>
        const toggleAudioButton = document.getElementById('toggleAudioButton');
        const statusDiv = document.getElementById('status');
        const queryInput = document.getElementById('queryInput');
        const queryButton = document.getElementById('queryButton');
        const queryResultDiv = document.getElementById('queryResult');
        // Get meter elements
        const volumeMeterContainer = document.getElementById('volumeMeterContainer');
        const volumeLevelDiv = document.getElementById('volumeLevel');


        // --- Config ---
        const SERVER_URL = `${window.location.hostname}:${window.location.port}`;
        const TARGET_SAMPLE_RATE = 16000;
        const WORKLET_PROCESSOR_NAME = 'audio-processor';
        const WORKLET_PATH = '/static/audio-processor.js';
        const CID_REGEX = /baf[ky][a-z2-7]{50,}/gi;
        const IPFS_GATEWAY = "https://gateway.lighthouse.storage/ipfs/";

        // --- State ---
        let socket = null;
        let audioContext = null;
        let microphoneNode = null;
        let audioWorkletNode = null;
        let analyserNode = null; // For volume meter
        let volumeDataArray = null; // To store volume data
        let volumeAnimationId = null; // To control animation loop
        let isStreaming = false;
        let sourceStream = null;

        // --- Socket.IO Connection ---
        // (connectSocket function remains the same)
        function connectSocket() {
            if (socket && socket.connected) return;
            updateStatus("Connecting...");
            socket = io(SERVER_URL);

            socket.on('connect', () => {
                updateStatus("Connected. Ready.");
                toggleAudioButton.disabled = false;
                queryButton.disabled = false;
                queryInput.disabled = false;
            });

            socket.on('disconnect', (reason) => {
                updateStatus(`Disconnected: ${reason}`, true);
                if (isStreaming) { forceStopStreamingCleanup(); }
                toggleAudioButton.textContent = 'Start Listening';
                toggleAudioButton.disabled = true;
                queryButton.disabled = true;
                queryInput.disabled = true;
            });

            socket.on('connect_error', (err) => {
                updateStatus(`Connection error: ${err.message}`, true);
                toggleAudioButton.disabled = true;
                queryButton.disabled = true;
                queryInput.disabled = true;
            });

            socket.on('error', (data) => {
                updateStatus(`Server error: ${data.message}`, true);
            });

             socket.on('query_result', (data) => {
                console.log("Query result:", data);
                queryButton.disabled = false; queryInput.disabled = false;
                queryResultDiv.classList.remove('error');
                if (data.processing) { queryResultDiv.textContent = data.answer; }
                else if (data.error || !data.answer) { queryResultDiv.textContent = `Error: ${data.answer || 'Empty response'}`; queryResultDiv.classList.add('error'); }
                else {
                    const rawAnswer = data.answer; queryResultDiv.textContent = rawAnswer;
                    let currentHtml = queryResultDiv.innerHTML;
                    const updatedHtml = currentHtml.replace(CID_REGEX, (cid) => {
                        const linkUrl = `${IPFS_GATEWAY}${cid}`;
                        return `<a href="${linkUrl}" target="_blank" rel="noopener noreferrer">${cid}</a>`;
                    });
                    queryResultDiv.innerHTML = updatedHtml;
                }
            });

             socket.on('audio_started', () => {
                if (!isStreaming) { console.log("Ignoring stale audio_started"); return; }
                updateStatus("Streaming audio...");
                toggleAudioButton.textContent = 'Stop Listening';
                toggleAudioButton.disabled = false;
                // *** Show volume meter ***
                volumeMeterContainer.classList.remove('hidden');
                // *** Start volume animation ***
                drawVolumeMeter();
            });

            socket.on('audio_stopped', (data) => {
                const reason = data?.message || "Server initiated stop";
                updateStatus(`Stopped: ${reason}`);
                 if (isStreaming) { forceStopStreamingCleanup(); }
                toggleAudioButton.textContent = 'Start Listening';
                toggleAudioButton.disabled = !(socket && socket.connected);
                 // *** Hide volume meter ***
                 volumeMeterContainer.classList.add('hidden');
                 // Ensure animation stops if not already stopped
                 if (volumeAnimationId) { cancelAnimationFrame(volumeAnimationId); volumeAnimationId = null; }
            });
        }

        // --- Audio Processing ---
        async function startStreaming() {
             if (isStreaming || !socket || !socket.connected) return;
             updateStatus("Initializing audio...");
             toggleAudioButton.disabled = true;
             try {
                 if (!audioContext || audioContext.state === 'closed') audioContext = new AudioContext({ sampleRate: TARGET_SAMPLE_RATE });
                 if (audioContext.state === 'suspended') await audioContext.resume();
                 if (!audioContext.audioWorklet) { updateStatus("Error: AudioWorklet unavailable (HTTPS required).", true); toggleAudioButton.disabled = false; return; }
                 try { await audioContext.audioWorklet.addModule(WORKLET_PATH); } catch (e) { updateStatus(`Error: Could not load audio processor. ${e.message}`, true); toggleAudioButton.disabled = false; return; }

                 sourceStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, sampleRate: TARGET_SAMPLE_RATE } });
                 microphoneNode = audioContext.createMediaStreamSource(sourceStream);
                 audioWorkletNode = new AudioWorkletNode(audioContext, WORKLET_PROCESSOR_NAME);

                 // *** Create and configure AnalyserNode ***
                 analyserNode = audioContext.createAnalyser();
                 analyserNode.fftSize = 256; // Smaller size for faster processing, adjust as needed
                 const bufferLength = analyserNode.frequencyBinCount;
                 volumeDataArray = new Uint8Array(bufferLength); // Use time domain data
                 console.log("AnalyserNode created with bufferLength:", bufferLength);

                 audioWorkletNode.port.onmessage = (event) => { if (socket && socket.connected && isStreaming) socket.emit('audio_chunk', event.data); };
                 audioWorkletNode.port.onerror = (event) => { updateStatus(`Audio processing error: ${event.message || 'Unknown'}`, true); stopStreaming(); };

                 // Connect mic -> worklet -> destination
                 microphoneNode.connect(audioWorkletNode);
                 audioWorkletNode.connect(audioContext.destination);
                 // *** Connect mic -> analyser as well ***
                 microphoneNode.connect(analyserNode);
                 // Analyser output doesn't need to go anywhere

                 socket.emit('start_audio');
                 isStreaming = true;
                 updateStatus("Waiting for server confirmation...");
             } catch (err) { updateStatus(`Error: ${err.message}`, true); forceStopStreamingCleanup(); toggleAudioButton.disabled = !(socket && socket.connected); }
         }

        function stopStreaming() {
             if (!isStreaming) return;
             console.log("User requested stop.");
             isStreaming = false; // Set immediately
             if (socket && socket.connected) socket.emit('stop_audio');
             forceStopStreamingCleanup(); // Local cleanup
             toggleAudioButton.textContent = 'Start Listening';
             updateStatus("Stopped listening.");
             toggleAudioButton.disabled = !(socket && socket.connected);
             // Hiding meter happens in 'audio_stopped' handler or forceStopStreamingCleanup
        }

        function forceStopStreamingCleanup() {
             console.log("Cleaning up audio resources...");
             isStreaming = false; // Ensure flag is false

             // *** Cancel volume animation ***
             if (volumeAnimationId) {
                 cancelAnimationFrame(volumeAnimationId);
                 volumeAnimationId = null;
                 console.log("Volume animation cancelled.");
             }
              // *** Hide and reset volume meter ***
             volumeMeterContainer.classList.add('hidden');
             volumeLevelDiv.style.width = '0%';


             if (audioWorkletNode) { audioWorkletNode.port.onmessage = null; audioWorkletNode.port.onerror = null; try { audioWorkletNode.disconnect(); } catch(e){} audioWorkletNode = null; console.log("Worklet disconnected."); }
             if (analyserNode) { try { analyserNode.disconnect(); } catch(e){} analyserNode = null; console.log("Analyser disconnected."); } // *** Disconnect analyser ***
             if (microphoneNode) { try { microphoneNode.disconnect(); } catch(e){} microphoneNode = null; console.log("Mic node disconnected."); }
             if (sourceStream) { sourceStream.getTracks().forEach(track => track.stop()); sourceStream = null; console.log("Mic stream stopped."); }

             console.log("Audio cleanup finished.");
        }

        // --- NEW: Volume Meter Drawing Function ---
        function drawVolumeMeter() {
            // Request the next frame
            volumeAnimationId = requestAnimationFrame(drawVolumeMeter);

            if (!analyserNode || !volumeDataArray) return;

            // Get time domain data
            analyserNode.getByteTimeDomainData(volumeDataArray);

            // Calculate a simple volume metric (e.g., max deviation from midpoint)
            let maxVal = 0;
            for (let i = 0; i < volumeDataArray.length; i++) {
                // Values are 0-255, midpoint is 128
                const deviation = Math.abs(volumeDataArray[i] - 128);
                if (deviation > maxVal) {
                    maxVal = deviation;
                }
            }

            // Normalize maxVal (0-128) to a percentage (0-100)
            const volumePercent = (maxVal / 128) * 100;

            // Update the width of the volume level div
            volumeLevelDiv.style.width = volumePercent + '%';
        }


        // --- Query Handling ---
        // (Keep sendQuery as before)
         function sendQuery() {
             const query = queryInput.value.trim();
             if (!query) { queryResultDiv.textContent = "Please enter a query."; queryResultDiv.classList.add('error'); return; }
             if (!socket || !socket.connected) { queryResultDiv.textContent = "Not connected."; queryResultDiv.classList.add('error'); return; }
             queryResultDiv.textContent = "Sending query..."; queryResultDiv.classList.remove('error');
             queryButton.disabled = true; queryInput.disabled = true;
             socket.emit('query_graph', { query: query });
         }

        // --- Status Update ---
        // (Keep updateStatus as before)
        function updateStatus(message, isError = false) {
            console.log(`Status: ${message}`);
            statusDiv.textContent = `Status: ${message}`;
            statusDiv.className = isError ? 'error' : '';
        }

        // --- Event Listeners ---
        // (Keep event listeners as before)
        toggleAudioButton.addEventListener('click', () => { if (!isStreaming) startStreaming(); else stopStreaming(); });
        queryButton.addEventListener('click', sendQuery);
        queryInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') { event.preventDefault(); sendQuery(); } });
        document.addEventListener('DOMContentLoaded', () => { connectSocket(); toggleAudioButton.disabled = true; queryButton.disabled = true; queryInput.disabled = true; });
        window.addEventListener('beforeunload', () => { if (socket) socket.disconnect(); });

    </script>
</body>
</html>
